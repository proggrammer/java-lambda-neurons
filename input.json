{
  "title": "Java lambda",
  "explanation": "Lambda Expressions were added in Java 8.\n\nA lambda expression is a short block of code which takes in parameters and returns a value. Lambda expressions are similar to methods, but they do not need a name and they can be implemented right in the body of a method.",
  "problems": {
    "0": {
      "problem": "How are we going to learn? ...mmm... \"by solving problems.\" Toggle me, or click me..",
      "code": [
        "View code."
      ],
      "fullCode": [
        "import java.util.List;\nimport java.util.stream.Collectors;\nimport java.util.stream.IntStream;\n\npublic class TestMain {\n    public static void main(String[] args)  {\n        System.out.println(sum(100));\n    }\n    public static List<Integer> sum(int n)    {\n        return IntStream.range(1,n).mapToObj(i->i).collect(Collectors.toList());\n    }\n}\n"
      ],
      "output": [
        "View output."
      ],
      "explanation": [
        "View Explanations.\nCheck out following examples: Toggle them."
      ]
    },
    "1": {
      "problem": "SUM of ALL integers from 1 to 100",
      "code": [
        "int sum = IntStream.range(1,101).sum()"
      ],
      "fullCode": [
        "import java.util.List;\nimport java.util.stream.Collectors;\nimport java.util.stream.IntStream;\n\npublic class TestMain {\n    public static void main(String[] args)  {\n        System.out.println(sum(100));\n    }\n    public static List<Integer> sum(int n)    {\n        return IntStream.range(1,n).mapToObj(i->i).collect(Collectors.toList());\n    }\n}\n"
      ],
      "output": [
        "sum: 5050"
      ],
      "explanation": [
        "IntStream: A sequence of primitive int-valued elements.\nIntStream sum() : returns the sum of elements in this stream."
      ]
    },
    "2": {
      "problem": "SUM of SQUARES of each integer from 1 to 100",
      "code": ["int squareSum = IntStream.range(1,101).map(i -> i*i).sum()"],
      "fullCode": [],
      "output": ["squareSum: 338350"],
      "explanation": []
    },
    "3": {
      "problem": "SUM of ALL EVEN integers from 1 to 100",
      "code": ["int evenSum = IntStream.range(1,101).filter(i -> i%2==0).sum()"],
      "fullCode": [],
      "output": ["evenSum: 2550"],
      "explanation": []
    },

    "4": {
      "problem": "LIST to ARRAY - filter only even elements.",
      "code": ["int[] result = Arrays.asList(1, 2, 3, 4).stream().filter(i -> i%2==0).mapToInt(i->i).toArray();\nSystem.out.println(Arrays.toString(result));"],
      "fullCode": [],
      "output": ["[2, 4]"],
      "explanation": []
    },
    "5": {
      "problem": "ARRAY to LIST - filter only even elements.",
      "code": ["int[] inputArray = new int[]{1,2,3,4};\nList<Integer> result = Arrays.stream(inputArray).filter(i -> i%2==0).boxed().collect(Collectors.toList());\nSystem.out.println(result);"],
      "fullCode": [],
      "output": ["[2, 4]"],
      "explanation": []
    },
    "6": {
      "problem": "LIST to MAP - for each element as key, and total count as value.",
      "code": ["List<Integer> inputList = Arrays.asList(1,2, 3, 4, 1, 2, 1);\nMap<Integer, Long> mapResult = inputList.stream().collect(Collectors.groupingBy(x->x, Collectors.counting()));\nSystem.out.println(mapResult);"],
      "fullCode": [],
      "output": ["{1=3, 2=2, 3=1, 4=1}"],
      "explanation": []
    },
    "7": {
      "problem": "LIST to MAP - for each element as key, and total count as value. - ANOTHER WAY",
      "code": ["List<Integer> inputList = Arrays.asList(1,2, 3, 4, 1, 2, 1);\nMap<Integer, Integer> mapResult = inputList.stream().collect(Collectors.toMap(x->x, x->1, (x,y) -> (x+y)));\nSystem.out.println(mapResult);"],
      "fullCode": [],
      "output": ["{1=3, 2=2, 3=1, 4=1}"],
      "explanation": []
    },
    "8": {
      "problem": "Getting subList of a LIST - usage of skip and limit",
      "code": ["List<Integer> inputList = Arrays.asList(1,2, 3, 4, 6, 7, 8);\nList<Integer> resultSlicedList = inputList.stream().skip(2).limit(3).collect(Collectors.toList());\nSystem.out.println(resultSlicedList);"],
      "fullCode": [],
      "output": ["[3, 4, 6]"],
      "explanation": []
    },
    "9": {
      "problem": "FINDING an element if it exists - can be used with other conditions",
      "code": ["List<Integer> inputList = Arrays.asList(1,2, 3, 4, 6, 7, 8, 6);\nOptional<Integer> result = inputList.stream().filter(i -> i==6).findFirst();\nSystem.out.println(result);"],
      "fullCode": [],
      "output": ["Optional[6]"],
      "explanation": ["There is another api called findAny, name itself defines it. Re-search yourself to learn more on that."]
    },
    "10": {
      "problem": "SUM of ALL integers from 1 to 100 - Another way",
      "code": ["int result = IntStream.range(1,101).reduce(0, (r,e) -> r+e);\nSystem.out.println(result);"],
      "fullCode": [],
      "output": ["5050"],
      "explanation": [""]
    },
    "11": {
      "problem": "SUM of ALL integers from 1 to 100 - Another way - compact one",
      "code": ["int result = IntStream.range(1,101).reduce(0, Integer::sum);\nSystem.out.println(result);"],
      "fullCode": [],
      "output": ["5050"],
      "explanation": [""]
    },
    "11": {
      "problem": "It's LAZY",
      "code": ["        int result = IntStream.range(-5,1).map(e -> {\n            System.out.println(e);\n            return 50/e;\n        }).sum();\n        System.out.println(result);"],
      "fullCode": [],
      "output": ["-5\n-4\n-3\n-2\n-1\n0\nException in thread \"main\" java.lang.ArithmeticException: / by zero..."],
      "explanation": [""]
    },
    "12": {
      "problem": "Being LAZY sometimes unlocks POWER",
      "code": ["        OptionalInt result = IntStream.range(-5,1).map(e -> {\n            System.out.println(e);\n            return 50/e;\n        }).filter(r -> r == -25).findFirst();\n        System.out.println(result);"],
      "fullCode": [],
      "output": ["-5\n-4\n-3\n-2\nOptionalInt[-25]"],
      "explanation": [""]
    },
    "12": {
      "problem": "Being LAZY sometimes unlocks POWER - lets check something till infinity - find the first element satisfying condition without any explicit limit",
      "code": ["        OptionalInt get5 = IntStream.iterate(0, i->i+1).filter(i-> {System.out.println(i); return i>=5;}).findFirst();\n        System.out.println(get5);"],
      "fullCode": [],
      "output": ["0\n1\n2\n3\n4\n5\nOptionalInt[5]"],
      "explanation": [""]
    },
    "13": {
      "problem": "Converting LIST of LIST to LIST - flattening the list",
      "code": ["        List<List<Integer>> list1 = Arrays.asList(Arrays.asList(1,2,3,4,5), Arrays.asList(10,20,30,40,50));\n        List<Integer> result = list1.stream().flatMap(list->list.stream()).collect(Collectors.toList());\n        System.out.println(result);"],
      "fullCode": [],
      "output": ["[1, 2, 3, 4, 5, 10, 20, 30, 40, 50]"],
      "explanation": [""]
    },
    "14": {
      "problem": "Power of REDUCE - generalised usage - convert LIST to SET",
      "code": ["        List<Integer> list1 = Arrays.asList(1,2,3,4,5,5);\n        Set<Integer> set = list1.stream().map(e -> Collections.singleton(e)).reduce(new HashSet<>(),\n                (partialResult, element) -> Stream.concat(partialResult.stream(), element.stream()).collect(Collectors.toSet())\n        );\n        System.out.println(set);"],
      "fullCode": [],
      "output": ["[1, 2, 3, 4, 5]"],
      "explanation": [""]
    },
    "15": {
      "problem": "Joining - printing list",
      "code": ["        List<Integer> list = Arrays.asList(1,2,3,4,5,5);\n        String listAsString = list.stream().map(e -> e.toString()).collect(Collectors.joining(\", \", \"[\",\"]\"));\n        System.out.println(listAsString);"],
      "fullCode": [],
      "output": ["[1, 2, 3, 4, 5]"],
      "explanation": [""]
    },
    "16": {
      "problem": "FINDING MAX in a list",
      "code": ["        List<Integer> list = Arrays.asList(1,2,3,4,5,5);\n        Optional<Integer> max = list.stream().max(Comparator.comparingInt(a -> a));\n        System.out.println(max);"],
      "fullCode": [],
      "output": ["Optional[5]"],
      "explanation": [" Similarly we can find min as well."]
    },
    "17": {
      "problem": "FINDING MAX in a list - another way",
      "code": ["        List<Integer> list = Arrays.asList(1,2,3,4,5,5);\n        Optional<Integer> max = list.stream().collect(Collectors.maxBy(Comparator.comparing(i->i)));\n        System.out.println(max);"],
      "fullCode": [],
      "output": ["Optional[5]"],
      "explanation": ["Here we are using Collectors."]
    },
    "18": {
      "problem": "SORT",
      "code": ["        List<Integer> list = Arrays.asList(1,5,3,4,5,2);\n        List<Integer> sorted = list.stream().sorted().collect(Collectors.toList());\n        System.out.println(sorted);"],
      "fullCode": [],
      "output": ["[1, 2, 3, 4, 5, 5]"],
      "explanation": [""]
    },
    "19": {
      "problem": "REVERSE SORT",
      "code": ["        List<Integer> list = Arrays.asList(1,5,3,4,5,2);\n        List<Integer> sorted = list.stream().sorted(Comparator.reverseOrder()).collect(Collectors.toList());\n        System.out.println(sorted);"],
      "fullCode": [],
      "output": ["[5, 5, 4, 3, 2, 1]"],
      "explanation": [""]
    },
    "19": {
      "problem": "Let's make it complex - find closest 3 elements for each element in a list (including the element)",
      "code": ["        List<Integer> list = Arrays.asList(-1,-2,0,9,1,5,3,4,5,2);\n        List<List<Integer>> result = list.stream().map(e -> list.stream().sorted(Comparator.comparing(eI -> Math.abs(eI-e))).limit(3).collect(Collectors.toList())).collect(Collectors.toList());\n        System.out.println(result);"],
      "fullCode": [],
      "output": ["[[-1, -2, 0], [-2, -1, 0], [0, -1, 1], [9, 5, 5], [1, 0, 2], [5, 5, 4], [3, 4, 2], [4, 5, 3], [5, 5, 4], [2, 1, 3]]"],
      "explanation": [""]
    },
    "20": {
      "problem": "FILTER a MAP - allow only even keys",
      "code": ["        Map<Integer, Integer> map = Map.ofEntries(entry(1, 1), entry(2, 2), entry(3, 3), entry(4, 4));\n        Map<Integer, Integer> outputMap = map.entrySet().stream().filter(es-> es.getKey()%2==0).collect(Collectors.toMap(x->x.getKey(), x->x.getValue()));\n        System.out.println(outputMap);"],
      "fullCode": [],
      "output": ["{2=2, 4=4}"],
      "explanation": [""]
    },
    "21": {
      "problem": "FILTER a MAP - parallel execution - can be applied most of examples here",
      "code": ["        Map<Integer, Integer> map = Map.ofEntries(entry(1, 1), entry(2, 2), entry(3, 3), entry(4, 4));\n        Map<Integer, Integer> outputMap = map.entrySet().stream().parallel().filter(es-> es.getKey()%2==0).collect(Collectors.toMap(x->x.getKey(), x->x.getValue()));\n        System.out.println(outputMap);"],
      "fullCode": [],
      "output": ["{2=2, 4=4}"],
      "explanation": [""]
    },
    "22": {
      "problem": "Its not fastest always",
      "code": [""],
      "fullCode": [],
      "output": [""],
      "explanation": [""]
    },
    "23": {
      "problem": "Exception is runtime",
      "code": ["        OptionalInt r = IntStream.iterate(-5, i->i+1).filter(i->1/i>0).findFirst();\n        System.out.println(r);"],
      "fullCode": [],
      "output": ["Exception in thread \"main\" java.lang.ArithmeticException: / by zero\n\tat SumNatural.lambda$main$1(SumNatural.java:13)..."],
      "explanation": ["These are unchecked, runtime exceptions."]
    },
    "24": {
      "problem": "Throwing \"catched\" exceptions from INSIDE the LAMBDA expressions",
      "code": ["import java.io.IOException;\nimport java.util.OptionalInt;\nimport java.util.stream.IntStream;\n\npublic class TestMain {\n    static class WrappedException extends RuntimeException {\n        Throwable cause;\n        WrappedException(Throwable cause) { this.cause = cause; }\n    }\n\n    static WrappedException throwWrapped(Throwable t) {\n        throw new WrappedException(t);\n    }\n\n    public static void main(String[] args) throws IOException{\n            try {\n                OptionalInt r = IntStream.iterate(-5, i -> i + 1).filter(i -> {\n                    try {\n                        return divideIt(i) > 0;\n                    } catch (IOException e) {\n                        throwWrapped(e);\n                    }\n                    return false;\n                }).findFirst();\n                System.out.println(r);\n            } catch (WrappedException we)   {\n                throw (IOException) we.cause;\n            }\n    }\n    public static int divideIt(int i)  throws IOException {\n        if(i==0) throw new IOException();\n        return 1/i;\n    }\n}\n"],
      "fullCode": [],
      "output": ["Exception in thread \"main\" java.io.IOException\n\tat SumNatural.divideIt(SumNatural.java:35)..."],
      "explanation": [""]
    },
    "25": {
      "problem": "Notes & Best Practices",
      "code": [""],
      "fullCode": [],
      "output": [""],
      "explanation": ["Follow links to know more about Java Lambda."]
    },
    "26": {
      "problem": "Some important links",
      "code": ["https://docs.oracle.com/javase/8/docs/api/java/util/stream/Collectors.html\nhttps://docs.oracle.com/javase/8/docs/api/java/util/stream/Stream.html\nhttps://docs.oracle.com/javase/8/docs/api/java/util/function/package-summary.html"],
      "fullCode": [],
      "output": [""],
      "explanation": ["Follow links to know more about Java Lambda."]
    }
  }
}